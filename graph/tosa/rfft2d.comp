/*
 * SPDX-FileCopyrightText: Copyright 2024-2025 Arm Limited and/or its affiliates <open-source-office@arm.com>
 * SPDX-License-Identifier: Apache-2.0
 */

layout(local_size_x = %warpX%) in;

layout(set = 0, binding = 0) uniform tensorARM<float, 3> outputRealData;
layout(set = 1, binding = 0) uniform tensorARM<float, 3> outputImagData;
layout(set = 2, binding = 0) uniform tensorARM<float, 3> inputData;

void main() {
    uint[3] index;
    getIndex3(outputRealData, index);

    uint on = index[0];
    uint oy = index[1];
    uint ox = index[2];
    uint N = tensorSizeARM(inputData, 0);
    uint H = tensorSizeARM(inputData, 1);
    uint W = tensorSizeARM(inputData, 2);

    double sumReal = 0.0;
    double sumImag = 0.0;

    bool skipImag = false;
    if (oy == 0 && (ox == 0 || ox == (W / 2))) {
        skipImag = true;
    } else if (oy == (H / 2) && (ox == 0 || ox == (W / 2))) {
        skipImag = true;
    }

    for (uint iy = 0; iy < H; iy++) {
        for (uint ix = 0; ix < W; ix += 4) {
            vec4 ixs = vec4(ix, ix + 1, ix + 2, ix + 3);

            float valueReal[4];
            tensorReadARM(inputData, uint[](on, iy, ix), valueReal);
            dvec4 valueRealVec = dvec4(valueReal[0], valueReal[1], valueReal[2], valueReal[3]);

            dvec4 angles = 2.0 * PI * (double(iy * oy) / H + ixs * ox / W);
            sumReal += dot(valueRealVec, cos(vec4(angles)));

            if (!skipImag) {
                sumImag += -dot(valueRealVec, sin(vec4(angles)));
            }
        }
    }

    tensorWriteARM(outputRealData, index, float(sumReal));
    tensorWriteARM(outputImagData, index, float(sumImag));
}
